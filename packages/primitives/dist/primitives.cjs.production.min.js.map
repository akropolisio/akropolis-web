{"version":3,"file":"primitives.cjs.production.min.js","sources":["../src/bnHexWei/utils/isHex.ts","../src/bnHexWei/utils/hexStripPrefix.ts","../src/bnHexWei/utils/hexToBn.ts","../src/bnHexWei/utils/isToBN.ts","../src/bnHexWei/utils/bnToBn.ts","../src/bnHexWei/utils/decimalsToWei.ts","../src/bnHexWei/utils/fromBaseUnit.ts","../src/bnHexWei/utils/getSignificantValue.ts","../src/bnHexWei/utils/isEqualHex.ts","../src/bnHexWei/utils/toBaseUnit.ts","../src/bnHexWei/utils/getDecimal.ts","../src/bnHexWei/format/formatInteger.ts","../src/bnHexWei/format/balance/types.ts","../src/bnHexWei/format/balance/makeFormattedBalance.ts","../src/bnHexWei/format/balance/formatBalance.ts","../src/fraction/index.ts","../src/entities/Currency.ts","../src/entities/Token.ts","../src/entities/amount/Amount.ts","../src/entities/TokenAmount.ts","../src/entities/PercentAmount.ts","../src/entities/LiquidityAmount.ts","../src/constants/index.ts","../src/entities/AllCoinsToken.ts","../src/entities/amount/utils/calcAvg.ts","../src/entities/amount/utils/denormolizeAmount.ts","../src/bnHexWei/utils/max.ts","../src/bnHexWei/utils/min.ts","../src/entities/amount/utils/normalizeAmounts.ts","../src/bnHexWei/utils/roundWei.ts","../src/entities/amount/utils/sumTokenAmountsByToken.ts"],"sourcesContent":["const HEX_REGEX = /^0x[a-fA-F0-9]+$/;\n\nexport function isHex(value: any, bitLength = -1, ignoreLength = false): value is string {\n  const isValidHex =\n    value === '0x' ||\n    ((typeof value === 'string' || value instanceof String) && HEX_REGEX.test(value.toString()));\n\n  if (isValidHex && bitLength !== -1) {\n    return value.length === 2 + Math.ceil(bitLength / 4);\n  }\n\n  return isValidHex && (ignoreLength || value.length % 2 === 0);\n}\n","import { isHex } from './isHex';\n\nconst UNPREFIX_HEX_REGEX = /^[a-fA-F0-9]+$/;\n\nexport function hexStripPrefix(value?: string | null): string {\n  if (!value) {\n    return '';\n  }\n\n  const hasPrefix = !!(value && isHex(value, -1, true) && value.substr(0, 2) === '0x');\n\n  if (hasPrefix) {\n    return value.substr(2);\n  }\n\n  if (UNPREFIX_HEX_REGEX.test(value)) {\n    return value;\n  }\n\n  throw new Error(`Invalid hex ${value} passed to hexStripPrefix`);\n}\n","import BN from 'bn.js';\n\nimport { hexStripPrefix } from './hexStripPrefix';\n\ninterface ToBnOptions {\n  isLe?: boolean;\n  isNegative?: boolean;\n}\n\nfunction reverse(value: string): string {\n  return (value.match(new RegExp('.{1,2}', 'g')) || []).reverse().join('');\n}\n\nexport function hexToBn(\n  value?: string | number | null,\n  options: ToBnOptions | boolean = { isLe: false, isNegative: false },\n): BN {\n  if (!value) {\n    return new BN(0);\n  }\n\n  const newOptions: ToBnOptions = {\n    isLe: false,\n    isNegative: false,\n    ...(typeof options === 'boolean' ? { isLe: options } : options),\n  };\n\n  const newValue = hexStripPrefix(value as string);\n  const bn = new BN((newOptions.isLe ? reverse(newValue) : newValue) || '00', 16);\n\n  return newOptions.isNegative ? bn.fromTwos(newValue.length * 4) : bn;\n}\n","import { IToBN } from '../types';\n\nexport function isToBN(value: unknown): value is IToBN {\n  return typeof value === 'object' && !!value && 'toBN' in value;\n}\n","import BN from 'bn.js';\n\nimport { IToBN } from '../types';\nimport { isHex } from './isHex';\nimport { hexToBn } from './hexToBn';\nimport { isToBN } from './isToBN';\n\nexport function bnToBn(value?: IToBN | BN | string | number | null): BN {\n  if (!value) {\n    return new BN(0);\n  }\n  if (isHex(value, undefined, true)) {\n    return hexToBn(value.toString());\n  }\n\n  const convertedToBnValue = isToBN(value) ? value.toBN() : new BN(value);\n\n  return BN.isBN(value) ? value : convertedToBnValue;\n}\n","import BN from 'bn.js';\n\nexport function decimalsToWei(decimals: number) {\n  return new BN(10).pow(new BN(decimals));\n}\n","import BN from 'bn.js';\n\nconst zero = new BN(0);\nconst negative1 = new BN(-1);\n\nexport function fromBaseUnit(input: BN | string, decimals: number): string {\n  let wei = new BN(input);\n  const negative = wei.lt(zero);\n  const base = new BN(10).pow(new BN(decimals));\n\n  if (negative) {\n    wei = wei.mul(negative1);\n  }\n\n  let fraction = wei.mod(base).toString(10);\n\n  while (fraction.length < decimals) {\n    fraction = `0${fraction}`;\n  }\n\n  fraction = fraction.replace(/^(.+?)0+$/, '$1');\n\n  const whole = wei.div(base).toString(10);\n\n  let value = `${whole}${fraction === '0' ? '' : `.${fraction}`}`;\n\n  if (negative) {\n    value = `-${value}`;\n  }\n\n  return value;\n}\n","import { ICurrency } from '../../entities';\nimport { decimalsToWei } from './decimalsToWei';\n\nexport function getSignificantValue(\n  { symbol, decimals }: ICurrency,\n  significantFractionalDigits?: number,\n) {\n  const fractionalDigits = significantFractionalDigits || getSignificantFractionalDigits(symbol);\n  return decimalsToWei(Math.max(0, decimals - fractionalDigits));\n}\n\n// fractional digits should be based on the equivalent of 0.01$ in a given currency\nfunction getSignificantFractionalDigits(currencySymbol: string): number {\n  switch (currencySymbol.toUpperCase()) {\n    case 'BTC':\n    case 'RENBTC':\n    case 'WBTC':\n    case 'SBTC':\n    case 'YFI': {\n      return 7;\n    }\n    default: {\n      return 5;\n    }\n  }\n}\n","export function isEqualHex(a: string, b: string) {\n  return a.toLowerCase() === b.toLowerCase();\n}\n","import BN from 'bn.js';\n\nconst negative1 = new BN(-1);\n\nexport function toBaseUnit(input: string, decimals: number): BN {\n  let inputStr = input;\n  const base = new BN(10).pow(new BN(decimals));\n\n  // Is it negative?\n  const negative = inputStr.substring(0, 1) === '-';\n  if (negative) {\n    inputStr = inputStr.substring(1);\n  }\n\n  if (inputStr === '.') {\n    throw new Error(`While converting number \"${input}\" to base units, invalid value`);\n  }\n\n  // Split it into a whole and fractional part\n  const comps = inputStr.split('.');\n  if (comps.length > 2) {\n    throw new Error(`While converting number \"${input}\" to base units, too many decimal points`);\n  }\n\n  let whole = comps[0];\n  let fraction = comps[1];\n\n  if (!whole) {\n    whole = '0';\n  }\n  if (!fraction) {\n    fraction = '';\n  }\n  if (fraction.length > decimals) {\n    throw new Error(`While converting number \"${input}\" to base units, too many decimal places`);\n  }\n\n  while (fraction.length < decimals) {\n    fraction += '0';\n  }\n\n  let inBaseUnit = new BN(whole).mul(base).add(new BN(fraction));\n\n  if (negative) {\n    inBaseUnit = inBaseUnit.mul(negative1);\n  }\n\n  return new BN(inBaseUnit.toString(10), 10);\n}\n","import { Decimal } from '../types';\n\nexport function getDecimal(value: string, baseDecimals: number, precision: number): Decimal {\n  if (value.length === 0 || value === '0') {\n    return { fractional: '', integer: '0' };\n  }\n\n  const isNegative = value[0].startsWith('-');\n  const positiveValue = isNegative ? value.substr(1) : value;\n\n  const mid = positiveValue.length - baseDecimals;\n  const integer = positiveValue.substr(0, mid);\n  const padding = mid < 0 ? 0 - mid : 0;\n\n  const minPrecision =\n    baseDecimals - precision > positiveValue.length - 1\n      ? baseDecimals - positiveValue.length + 1\n      : precision;\n  const decimalsZerosLength = baseDecimals < minPrecision ? baseDecimals : minPrecision;\n\n  // TODO: refactor\n  const fractional = `${`${'0'.repeat(padding)}${positiveValue}`.substr(\n    mid < 0 ? 0 : mid,\n  )}000`.substr(0, decimalsZerosLength);\n\n  return { fractional, integer: `${isNegative ? '-' : ''}${integer || '0'}` };\n}\n","const NUMBER_REGEX = new RegExp('(\\\\d+?)(?=(\\\\d{3})+(?!\\\\d)|$)', 'g');\n\nexport function formatInteger(value: string): string {\n  if (value.length === 0) {\n    return '0';\n  }\n\n  const isNegative = value[0].startsWith('-');\n  const matched = isNegative ? value.substr(1).match(NUMBER_REGEX) : value.match(NUMBER_REGEX);\n\n  return matched ? `${isNegative ? '-' : ''}${matched.join(',')}` : value;\n}\n","export type FormattedBalance = {\n  formatted: string;\n  detailed: {\n    startSymbol: string;\n    startSpace: string;\n    negativeSign: string;\n    integer: string;\n    decimalSeparator: string;\n    fractional: string;\n    siPower: string;\n    endSpace: string;\n    endSymbol: string;\n  };\n};\n\nexport type SI = {\n  power: number;\n  value: string;\n};\n\nexport type FormattingVariant = 'default' | 'trim-fractional-zeros';\n\nconst startPositions = ['start-space', 'start'] as const;\nconst endPositions = ['end-space', 'end'] as const;\ntype StartSymbolPosition = typeof startPositions[number];\ntype EndSymbolPosition = typeof endPositions[number];\n\nexport type SymbolPosition = StartSymbolPosition | EndSymbolPosition;\n\nexport function isStartPosition(value: SymbolPosition): value is StartSymbolPosition {\n  return (startPositions as Readonly<SymbolPosition[]>).includes(value);\n}\n","import { formatInteger } from '../formatInteger';\nimport { FormattedBalance, FormattingVariant, isStartPosition, SI, SymbolPosition } from './types';\n\nconst nbsp = 'Â ';\n\nexport function makeFormattedBalance({\n  rawInteger,\n  rawFractional = '',\n  symbolPosition,\n  tokenSymbol,\n  variant,\n  si,\n}: {\n  tokenSymbol: string;\n  symbolPosition: SymbolPosition;\n  rawInteger: string;\n  rawFractional?: string;\n  variant: FormattingVariant;\n  si?: SI | null;\n}): FormattedBalance {\n  const isStartUnit = isStartPosition(symbolPosition);\n  const isNegative = rawInteger[0]?.startsWith('-');\n\n  const startSymbol = isStartUnit ? tokenSymbol : '';\n  const startSpace = symbolPosition === 'start-space' ? nbsp : '';\n  const negativeSign = isNegative ? '-' : '';\n  const integer = formatInteger(isNegative ? rawInteger.substr(1) : rawInteger) || '0';\n  const fractional = {\n    default: () => rawFractional,\n    'trim-fractional-zeros': () => rawFractional.replace(/^(\\d*?)0*$/, '$1'),\n  }[variant]();\n  const decimalSeparator = fractional ? '.' : '';\n  const siPower = si?.value || '';\n  const endSpace = symbolPosition === 'end-space' ? nbsp : '';\n  const endSymbol = !isStartUnit ? tokenSymbol : '';\n\n  return {\n    formatted: [\n      startSymbol,\n      startSpace,\n      negativeSign,\n      integer,\n      decimalSeparator,\n      fractional,\n      siPower,\n      endSpace,\n      endSymbol,\n    ]\n      .join('')\n      .trim(),\n    detailed: {\n      startSymbol,\n      startSpace,\n      negativeSign,\n      integer,\n      decimalSeparator,\n      fractional,\n      siPower,\n      endSpace,\n      endSymbol,\n    },\n  };\n}\n","import BN from 'bn.js';\n\nimport { IToBN } from '../../types';\nimport { getDecimal, bnToBn } from '../../utils';\nimport { makeFormattedBalance } from './makeFormattedBalance';\nimport { FormattedBalance, FormattingVariant, SI, SymbolPosition } from './types';\n\ninterface IFormatBalanceOptions {\n  amountInBaseUnits: string | BN | IToBN;\n  baseDecimals: number;\n  tokenSymbol?: string;\n  precision?: number;\n  variant?: FormattingVariant;\n  symbolPosition?: SymbolPosition;\n  withSI?: boolean;\n}\n\nexport function formatBalance({\n  amountInBaseUnits,\n  baseDecimals,\n  tokenSymbol = '',\n  precision = 2,\n  variant = 'default',\n  symbolPosition = 'end-space',\n  withSI = false,\n}: IFormatBalanceOptions): FormattedBalance {\n  const balanceString = bnToBn(amountInBaseUnits).toString();\n\n  if (balanceString.length === 0 || balanceString === '0') {\n    return makeFormattedBalance({\n      rawInteger: '0',\n      rawFractional: '',\n      variant,\n      symbolPosition,\n      tokenSymbol,\n    });\n  }\n\n  const { fractional, integer } = getDecimal(balanceString, baseDecimals, precision);\n\n  const si = withSI ? calcSI(integer) : null;\n\n  if (!si) {\n    return makeFormattedBalance({\n      rawInteger: integer,\n      rawFractional: fractional,\n      variant,\n      symbolPosition,\n      tokenSymbol,\n    });\n  }\n\n  const { integer: integerSI, fractional: fractionalSI } = getDecimal(\n    balanceString,\n    baseDecimals + si.power,\n    precision,\n  );\n\n  return makeFormattedBalance({\n    rawInteger: integerSI,\n    rawFractional: fractionalSI,\n    variant,\n    symbolPosition,\n    tokenSymbol,\n    si,\n  });\n}\n\nexport function calcSI(baseNumber: string) {\n  const digit = baseNumber.length;\n  if (digit > 9) return precisions.billion;\n  if (digit > 6) return precisions.million;\n  if (digit > 3) return precisions.thousand;\n  return null;\n}\n\nexport const precisions: Record<string, SI> = {\n  thousand: {\n    power: 3,\n    value: 'K',\n  },\n  million: {\n    power: 6,\n    value: 'M',\n  },\n  billion: {\n    power: 9,\n    value: 'B',\n  },\n};\n","// eslint-disable-next-line max-classes-per-file\nimport BN from 'bn.js';\n\nimport { getDecimal, bnToBn, IToBN, Decimal, decimalsToWei } from '../bnHexWei';\n\nexport type Value = number | string | BN | IToBN | Fraction | IToFraction;\n\nexport interface IToFraction {\n  toFraction(): Fraction;\n}\n\nexport class Fraction implements IToBN {\n  static decimalsAccuracy = 18;\n  static maxWordsInNumerator = 96;\n\n  public readonly numerator: BN;\n  public readonly denominator: BN;\n\n  constructor(\n    numerator: string | number | BN | IToBN,\n    denominator: string | number | BN | IToBN = new BN(1),\n  ) {\n    const [roundedNumerator, roundedDenominator] = this.round(\n      bnToBn(numerator),\n      bnToBn(denominator),\n    );\n    this.numerator = roundedNumerator;\n    this.denominator = roundedDenominator;\n  }\n\n  static isFraction(value: unknown): value is Fraction {\n    return value instanceof Fraction;\n  }\n\n  toBN() {\n    return this.numerator.div(this.denominator);\n  }\n\n  public toDecimal(baseDecimals: number, precision: number): Decimal {\n    const multiplier = new BN(10).pow(new BN(precision));\n    return getDecimal(\n      this.numerator.mul(multiplier).div(this.denominator).toString(),\n      baseDecimals + precision,\n      precision,\n    );\n  }\n\n  add(value: Value) {\n    const { denominator, numerator } = toFraction(value);\n    return new Fraction(\n      this.numerator.mul(denominator).add(numerator.mul(this.denominator)),\n      this.denominator.mul(denominator),\n    );\n  }\n\n  sub(value: Value) {\n    const { denominator, numerator } = toFraction(value);\n    return new Fraction(\n      this.numerator.mul(denominator).sub(numerator.mul(this.denominator)),\n      this.denominator.mul(denominator),\n    );\n  }\n\n  div(value: Value) {\n    const { denominator, numerator } = toFraction(value);\n    return new Fraction(this.numerator.mul(denominator), this.denominator.mul(numerator));\n  }\n\n  mul(value: Value) {\n    const { denominator, numerator } = toFraction(value);\n    return new Fraction(this.numerator.mul(numerator), this.denominator.mul(denominator));\n  }\n\n  eq(value: Value): boolean {\n    return this.toBN().eq(toFraction(value).toBN());\n  }\n\n  gt(value: Value): boolean {\n    const { denominator, numerator } = toFraction(value);\n    return this.numerator.mul(denominator).gt(numerator.mul(this.denominator));\n  }\n\n  lt(value: Value): boolean {\n    const { denominator, numerator } = toFraction(value);\n    return this.numerator.mul(denominator).lt(numerator.mul(this.denominator));\n  }\n\n  lte(value: Value): boolean {\n    const { denominator, numerator } = toFraction(value);\n    return this.numerator.mul(denominator).lte(numerator.mul(this.denominator));\n  }\n\n  gte(value: Value): boolean {\n    const { denominator, numerator } = toFraction(value);\n    return this.numerator.mul(denominator).gte(numerator.mul(this.denominator));\n  }\n\n  abs(): Fraction {\n    return new Fraction(this.numerator.abs(), this.denominator.abs());\n  }\n\n  pow(rawPower: BN | IToBN | number) {\n    const power = bnToBn(rawPower);\n    return new Fraction(this.numerator.pow(power), this.denominator.pow(power));\n  }\n\n  isZero() {\n    return this.numerator.isZero();\n  }\n\n  isNeg() {\n    return this.numerator.isNeg();\n  }\n\n  toNumber() {\n    return parseFloat(this.toString());\n  }\n\n  toString() {\n    const fractionalPrecisionMultiplier = new BN(10).pow(new BN(Fraction.decimalsAccuracy));\n\n    const integer = this.numerator.div(this.denominator);\n    const remainder = this.numerator.sub(this.denominator.mul(integer));\n    const fractional = remainder\n      .add(this.denominator) // add one denominator so that after division we get result: `fractionalPrecisionMultiplier + fractional = 100023` (1.00023 without fractionalPrecisionMultiplier multiplying)\n      .mul(fractionalPrecisionMultiplier)\n      .div(this.denominator)\n      .toString()\n      .slice(1); // remove the first digit to take a fraction with padding 100023 -> 00023\n\n    return `${integer}.${fractional}`;\n  }\n\n  valueOf() {\n    return this.toNumber();\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  round(numerator: BN, denominator: BN) {\n    if ((numerator as any).length <= Fraction.maxWordsInNumerator) {\n      return [numerator, denominator];\n    }\n\n    return [\n      numerator.mul(decimalsToWei(Fraction.decimalsAccuracy)).div(denominator),\n      decimalsToWei(Fraction.decimalsAccuracy),\n    ];\n  }\n}\n\nexport function toFraction(value: Value): Fraction {\n  if (value instanceof Fraction) {\n    return value;\n  }\n  if (typeof value === 'object' && 'toFraction' in value) {\n    return value.toFraction();\n  }\n  if (typeof value === 'number') {\n    const integer = Math.floor(value);\n    const fractional = value - integer;\n\n    if (fractional) {\n      return new Fraction(fractional.toFixed(18).replace(/0\\.(\\d+)/, '1$1'), decimalsToWei(18))\n        .sub(new BN(1))\n        .add(new BN(integer));\n    }\n\n    return new Fraction(new BN(integer));\n  }\n  return new Fraction(value);\n}\n","import { IBrand } from '../bnHexWei';\n\nconst uniqType = Symbol('Currency');\n\nexport interface ICurrency {\n  readonly symbol: string;\n  readonly decimals: number;\n  toJSON(): { _type: string };\n  equals(a: this): boolean;\n}\n\nexport class Currency implements ICurrency, IBrand {\n  public _type: typeof uniqType = uniqType;\n\n  constructor(public readonly symbol: string, public readonly decimals: number) {}\n\n  toJSON(): { _type: string } {\n    const view: CurrencyJSONView = {\n      _type: 'Currency',\n      symbol: this.symbol,\n      decimals: this.decimals,\n    };\n\n    return view;\n  }\n\n  equals(a: Currency): boolean {\n    return this.symbol === a.symbol && this.decimals === a.decimals;\n  }\n}\n\ninterface CurrencyJSONView {\n  _type: 'Currency';\n  symbol: string;\n  decimals: number;\n}\n","import { IBrand, isEqualHex } from '../bnHexWei';\nimport { ICurrency } from './Currency';\n\nconst uniqType = Symbol('Token');\n\nexport type Network = 'eth' | 'bsc';\n\nexport class Token implements ICurrency, IBrand {\n  public _type: typeof uniqType = uniqType;\n\n  constructor(\n    public readonly address: string,\n    public readonly symbol: string,\n    public readonly decimals: number,\n    public readonly network: Network,\n  ) {}\n\n  toJSON() {\n    const view: TokenJSONView = {\n      _type: 'Token',\n      address: this.address,\n      symbol: this.symbol,\n      decimals: this.decimals,\n      network: this.network,\n    };\n\n    return view;\n  }\n\n  equals(a: Token): boolean {\n    return isEqualHex(this.address, a.address);\n  }\n}\n\ninterface TokenJSONView {\n  _type: 'Token';\n  address: string;\n  symbol: string;\n  decimals: number;\n  network: Network;\n}\n","import BN from 'bn.js';\n\nimport { IToBN, Decimal, FormattedBalance, getSignificantValue } from '../../bnHexWei';\nimport { Fraction, toFraction, Value, IToFraction } from '../../fraction';\nimport { ICurrency } from '../Currency';\n\nexport interface NormalizedAmount<T extends Amount> {\n  decimals: number;\n  value: Fraction;\n  original: T;\n}\n\nexport abstract class Amount<C extends ICurrency = ICurrency> implements IToBN, IToFraction {\n  public abstract _type: symbol;\n  private value: Fraction;\n\n  constructor(amount: Value, public readonly currency: C) {\n    this.value = toFraction(amount);\n  }\n\n  public abstract makeAmount(amount: Value, currency: C): this;\n  public abstract toFormattedBalance(\n    precision?: number,\n    withSymbol?: boolean,\n    withSI?: boolean,\n  ): FormattedBalance;\n\n  public toFormattedString(precision?: number, withSymbol?: boolean): string {\n    return this.toFormattedBalance(precision, withSymbol).formatted;\n  }\n\n  public toShortString(precision?: number, withSymbol?: boolean): string {\n    return this.toFormattedBalance(precision, withSymbol, true).formatted;\n  }\n\n  public withValue(newValue: Value): this {\n    return this.makeAmount(toFraction(newValue), this.currency);\n  }\n\n  public sub(value: Value): this {\n    return this.makeAmount(this.value.sub(toFraction(value)), this.currency);\n  }\n\n  public add(value: Value): this {\n    return this.makeAmount(this.value.add(toFraction(value)), this.currency);\n  }\n\n  public div(value: Value): this {\n    return this.makeAmount(this.value.div(toFraction(value)), this.currency);\n  }\n\n  public mul(value: Value): this {\n    return this.makeAmount(this.value.mul(toFraction(value)), this.currency);\n  }\n\n  public isZero(): boolean {\n    return this.value.isZero();\n  }\n\n  public isNeg(): boolean {\n    return this.value.isNeg();\n  }\n\n  public eq(value: this): boolean {\n    return this.eqValues(value) && this.currency.equals(value.currency);\n  }\n\n  public eqValues(value: Value): boolean {\n    return this.value.eq(toFraction(value));\n  }\n\n  // TODO make allowance for currency.decimals\n  public gt(value: Value): boolean {\n    return this.value.gt(toFraction(value));\n  }\n\n  public lt(value: Value): boolean {\n    return this.value.lt(toFraction(value));\n  }\n\n  public gte(value: Value): boolean {\n    return this.value.gte(toFraction(value));\n  }\n\n  public lte(value: Value): boolean {\n    return this.value.lte(toFraction(value));\n  }\n\n  public abs() {\n    return this.value.abs();\n  }\n\n  public pow(power: BN | IToBN | number) {\n    return this.value.pow(power);\n  }\n\n  public toBN(): BN {\n    return this.value.toBN();\n  }\n\n  public toFraction(): Fraction {\n    return this.value;\n  }\n\n  public toDecimal(precision: number): Decimal {\n    return this.value.toDecimal(this.currency.decimals, precision);\n  }\n\n  public toNumber(): number {\n    return this.value.toNumber();\n  }\n\n  public toString(base?: number | 'hex' | undefined, length?: number | undefined): string {\n    return this.toBN().toString(base, length);\n  }\n\n  public valueOf(): number {\n    return this.value.valueOf();\n  }\n\n  public toSignificantValue(significantFractionalDigits?: number): this {\n    const minSignificantValue = getSignificantValue(this.currency, significantFractionalDigits);\n    return this.gte(minSignificantValue) ? this : this.makeAmount(0, this.currency);\n  }\n}\n","import { formatBalance, FormattedBalance } from '../bnHexWei';\nimport { Value } from '../fraction';\nimport { Token } from './Token';\nimport { Amount } from './amount/Amount';\n\nconst uniqType = Symbol('TokenAmount');\n\nexport class TokenAmount extends Amount<Token> {\n  public _type: typeof uniqType = uniqType;\n\n  // eslint-disable-next-line class-methods-use-this\n  public makeAmount(amount: Value, token: Token): this {\n    return new TokenAmount(amount, token) as this;\n  }\n\n  public toFormattedBalance(\n    precision: number = 2,\n    withSymbol = true,\n    withSI?: boolean,\n  ): FormattedBalance {\n    return formatBalance({\n      withSI,\n      amountInBaseUnits: this.toBN(),\n      tokenSymbol: withSymbol ? this.currency.symbol : undefined,\n      baseDecimals: this.currency.decimals,\n      precision,\n      symbolPosition: 'end-space',\n    });\n  }\n\n  public withToken(newToken: Token): TokenAmount {\n    return new TokenAmount(this.toFraction(), newToken);\n  }\n}\n","import BN from 'bn.js';\n\nimport { formatBalance, FormattedBalance } from '../bnHexWei';\nimport { Value } from '../fraction';\nimport { Amount } from './amount';\nimport { Currency } from './Currency';\n\nconst uniqType = Symbol('PercentAmount');\n\nexport class PercentAmount extends Amount<Currency> {\n  public _type: typeof uniqType = uniqType;\n\n  constructor(amount: Value) {\n    super(amount, new Currency('%', 0));\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  public makeAmount(amount: Value): this {\n    return new PercentAmount(amount) as this;\n  }\n\n  public toFormattedBalance(\n    precision: number = 2,\n    withSymbol = true,\n    withSI?: boolean,\n  ): FormattedBalance {\n    const multiplier = new BN(10).pow(new BN(precision));\n    const value = this.toFraction().mul(multiplier);\n\n    return formatBalance({\n      withSI,\n      amountInBaseUnits: value.toBN(),\n      tokenSymbol: withSymbol ? this.currency.symbol : undefined,\n      baseDecimals: precision,\n      precision,\n      symbolPosition: 'end',\n    });\n  }\n}\n","import { formatBalance, FormattedBalance } from '../bnHexWei';\nimport { Value } from '../fraction';\nimport { Amount } from './amount';\nimport { Currency } from './Currency';\n\ntype SymbolPosition = 'start-space' | 'start' | 'end-space' | 'end';\nconst uniqType = Symbol('LiquidityAmount type');\n\nexport class LiquidityAmount extends Amount<Currency> {\n  public _type: typeof uniqType = uniqType;\n\n  private readonly defaultPrecision: number = this.options?.precisions || 2;\n  private readonly defaultSymbolPosition: SymbolPosition = this.options?.symbolPosition || 'start';\n\n  constructor(\n    amount: Value,\n    currency: Currency,\n    private options?: { precisions?: number; symbolPosition?: SymbolPosition },\n  ) {\n    super(amount, currency);\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  public makeAmount(amount: Value, currency: Currency): this {\n    return new LiquidityAmount(amount, currency, this.options) as this;\n  }\n\n  public toFormattedBalance(\n    precision: number = this.defaultPrecision,\n    withSymbol = true,\n    withSI?: boolean,\n  ): FormattedBalance {\n    return formatBalance({\n      withSI,\n      amountInBaseUnits: this.toBN(),\n      tokenSymbol: withSymbol ? this.currency.symbol : undefined,\n      baseDecimals: this.currency.decimals,\n      precision,\n      symbolPosition: this.defaultSymbolPosition,\n    });\n  }\n}\n","export const zeroAddress = '0x0000000000000000000000000000000000000000';\n\nexport const mainnetTokens = {\n  AKRO: '0x8ab7404063ec4dbcfd4598215992dc3f8ec853d7',\n  COMP: '0xc00e94cb662c3520282e6f5717214004a7f26888',\n  CRV: '0xd533a949740bb3306d119cc777fa900ba034cd52',\n  DAI: '0x6b175474e89094c44da98b954eedeac495271d0f',\n  SNX: '0xc011a73ee8576fb46f5e1c5751ca3b9fe0af2a6f',\n  TUSD: '0x0000000000085d4780b73119b644ae5ecd22b376',\n  USDC: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',\n  USDT: '0xdac17f958d2ee523a2206206994597c13d831ec7',\n  bUSD: '0x4fabb145d64652a948d72533023f6e7a623c7c53',\n  sUSD: '0x57ab1ec28d129707052df4df418d58a2d46d5f51',\n  '3Crv': '0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490',\n  crvSBTC: '0x075b1bb99792c9E1041bA13afEf80C91a1e70fB3',\n  crvBUSD: '0x3B3Ac5386837Dc563660FB6a0937DFAa5924333B',\n  crvCOMP: '0x845838DF265Dcd2c412A1Dc9e959c7d08537f8a2',\n  yCRV: '0xdf5e0e81dff6faf3a7e52ba697820c5e32d806a8',\n};\n","import { Token } from './Token';\nimport { zeroAddress } from '../constants';\n\nexport class AllCoinsToken extends Token {\n  constructor(public readonly tokens?: Token[], symbol: string = 'All Coins') {\n    super(zeroAddress, symbol, 18, 'eth');\n  }\n}\n","import { Value, toFraction, Fraction } from '../../../fraction';\n\ntype Input = {\n  value: Value;\n  weight?: Value;\n};\n\n/**\n * Calculate average value with values weight\n * @return avg(x1, x2) = (x1.value * x1.weight + x2.value * x2.weight) / (x1.weight + x2.weight)\n */\nexport function calcAvg(...rest: Input[]): Fraction {\n  if (rest.length <= 1) {\n    return toFraction((rest.length && rest[0].value) || 0);\n  }\n\n  const avg = rest.reduce((x1, x2) => {\n    const weight1 = toFraction(x1.weight || 1);\n    const weight2 = toFraction(x2.weight || 1);\n    const value1 = toFraction(x1.value);\n    const value2 = toFraction(x2.value);\n\n    const fullWeight = weight1.add(weight2);\n\n    if (fullWeight.isZero()) {\n      return { value: 0, weight: 0 };\n    }\n\n    return {\n      value: value1.mul(weight1).add(value2.mul(weight2)).div(fullWeight),\n      weight: fullWeight,\n    };\n  });\n\n  return toFraction(avg.value);\n}\n","import { decimalsToWei } from '../../../bnHexWei';\nimport { TokenAmount } from '../../TokenAmount';\nimport { Token } from '../../Token';\nimport { Amount } from '../Amount';\n\n// TODO: Fix spelling denormolize > denormalize\nexport function denormolizeAmount<T extends Amount>(amount: T, token: Token): TokenAmount {\n  const fractionAmount = amount.toFraction();\n\n  return new TokenAmount(\n    amount.currency.decimals > token.decimals\n      ? fractionAmount.div(decimalsToWei(amount.currency.decimals - token.decimals))\n      : fractionAmount.mul(decimalsToWei(token.decimals - amount.currency.decimals)),\n    token,\n  );\n}\n","import BN from 'bn.js';\n\nimport { IToBN } from '../types';\nimport { bnToBn } from './bnToBn';\n\nexport function max<Value extends IToBN | BN | string | number | null>(\n  first: Value,\n  ...rest: Array<Value>\n): Value {\n  return rest.reduce((acc, cur) => {\n    const accBn = bnToBn(acc);\n    const curBn = bnToBn(cur);\n\n    return accBn.gt(curBn) ? acc : cur;\n  }, first);\n}\n","import BN from 'bn.js';\n\nimport { IToBN } from '../types';\nimport { bnToBn } from './bnToBn';\n\nexport function min<Value extends IToBN | BN | string | number | null>(\n  first: Value,\n  ...rest: Array<Value>\n): Value {\n  return rest.reduce<Value>((acc, cur) => {\n    const accBn = bnToBn(acc);\n    const curBn = bnToBn(cur);\n\n    return accBn.lt(curBn) ? acc : cur;\n  }, first);\n}\n","import { decimalsToWei } from '../../../bnHexWei';\nimport { Amount, NormalizedAmount } from '../Amount';\n\nexport function normalizeAmounts<T extends Amount>(\n  amounts: T[],\n  decimals?: number,\n): NormalizedAmount<T>[] {\n  if (amounts.length < 1) {\n    return [];\n  }\n\n  const maxDecimal =\n    decimals !== undefined\n      ? decimals\n      : amounts\n          .map(amount => amount.currency.decimals)\n          .reduce((max, current) => (current > max ? current : max));\n\n  return amounts.map(amount => {\n    const diff = maxDecimal - amount.currency.decimals;\n    return {\n      decimals: maxDecimal,\n      original: amount,\n      value:\n        diff >= 0\n          ? amount.toFraction().mul(decimalsToWei(diff))\n          : amount.toFraction().div(decimalsToWei(-diff)),\n    };\n  });\n}\n","import BN from 'bn.js';\n\nimport { decimalsToWei } from './decimalsToWei';\n\nexport function roundWei(\n  value: string | BN,\n  decimals: number,\n  variant: 'ceil' | 'floor' | 'half-away-from-zero',\n  significant: number,\n): BN {\n  const bnValue = new BN(value);\n\n  const multiplierDecimals = Math.max(0, decimals - significant);\n  const multiplier = decimalsToWei(multiplierDecimals);\n\n  if (!multiplierDecimals) {\n    return bnValue;\n  }\n\n  const absFloorRounded = bnValue.abs().div(multiplier).mul(multiplier);\n  const mod = bnValue.sub(absFloorRounded);\n\n  const isNeedUpToCeil =\n    (variant === 'ceil' && !bnValue.eq(absFloorRounded)) ||\n    (variant === 'half-away-from-zero' && mod.gte(multiplier.divn(2)));\n\n  return absFloorRounded\n    .add(isNeedUpToCeil ? multiplier : new BN(0))\n    .muln(bnValue.isNeg() ? -1 : 1);\n}\n","import { TokenAmount } from '../../TokenAmount';\n\nexport function sumTokenAmountsByToken(amounts: TokenAmount[]): TokenAmount[] {\n  const reducedAmounts = amounts.reduce((acc, cur) => {\n    const prev = acc.get(cur.currency.address)?.toFraction() || 0;\n    acc.set(cur.currency.address, cur.add(prev));\n    return acc;\n  }, new Map<string, TokenAmount>());\n\n  return Array.from(reducedAmounts.values());\n}\n"],"names":["HEX_REGEX","isHex","value","bitLength","ignoreLength","isValidHex","String","test","toString","length","Math","ceil","UNPREFIX_HEX_REGEX","hexStripPrefix","substr","Error","hexToBn","options","isLe","isNegative","BN","newOptions","newValue","bn","match","RegExp","reverse","join","fromTwos","isToBN","bnToBn","undefined","convertedToBnValue","toBN","isBN","decimalsToWei","decimals","pow","zero","negative1","getSignificantValue","significantFractionalDigits","fractionalDigits","currencySymbol","toUpperCase","getSignificantFractionalDigits","symbol","max","isEqualHex","a","b","toLowerCase","getDecimal","baseDecimals","precision","fractional","integer","startsWith","positiveValue","mid","minPrecision","decimalsZerosLength","repeat","NUMBER_REGEX","formatInteger","matched","startPositions","makeFormattedBalance","rawInteger","rawFractional","symbolPosition","tokenSymbol","variant","si","isStartUnit","includes","_rawInteger$","startSymbol","startSpace","negativeSign","replace","decimalSeparator","siPower","endSpace","endSymbol","formatted","trim","detailed","formatBalance","withSI","balanceString","amountInBaseUnits","digit","precisions","billion","million","thousand","power","Fraction","numerator","denominator","this","round","roundedDenominator","isFraction","div","toDecimal","multiplier","mul","add","toFraction","sub","eq","gt","lt","lte","gte","abs","rawPower","isZero","isNeg","toNumber","parseFloat","fractionalPrecisionMultiplier","decimalsAccuracy","slice","valueOf","maxWordsInNumerator","floor","toFixed","uniqType","Symbol","Currency","toJSON","_type","equals","Token","address","network","Amount","amount","currency","toFormattedString","withSymbol","toFormattedBalance","toShortString","withValue","makeAmount","eqValues","base","toSignificantValue","minSignificantValue","TokenAmount","token","withToken","newToken","PercentAmount","LiquidityAmount","defaultPrecision","defaultSymbolPosition","zeroAddress","tokens","rest","avg","reduce","x1","x2","weight1","weight","weight2","value1","value2","fullWeight","fractionAmount","input","wei","negative","fraction","mod","AKRO","COMP","CRV","DAI","SNX","TUSD","USDC","USDT","bUSD","sUSD","crvSBTC","crvBUSD","crvCOMP","yCRV","first","acc","cur","accBn","curBn","amounts","maxDecimal","map","current","diff","original","significant","bnValue","multiplierDecimals","absFloorRounded","isNeedUpToCeil","divn","muln","reducedAmounts","prev","get","set","Map","Array","from","values","inputStr","substring","comps","split","whole","inBaseUnit"],"mappings":"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"}